from typing import List
from ..models.robot import RobotConfig
from ..models.track import Track, TrackGraph
from ..models.firmware import SpeedSegment, FirmwareConfig
from .track_service import TrackService

class FirmwareService:
    """Service for generating firmware based on track and robot configuration"""
    
    @staticmethod
    def generate_speed_strategy(track: Track, robot: RobotConfig) -> List[SpeedSegment]:
        """Generate segment-based speed and PID strategy"""
        graph = TrackService.track_to_graph(track)
        
        if not graph.valid_path:
            return []
        
        segments = []
        for i, element_id in enumerate(graph.valid_path):
            element = next((e for e in track.elements if e.id == element_id), None)
            if not element:
                continue
            
            # Adjust speed based on element type
            base_speed = robot.base_speed
            max_speed = robot.max_speed
            pid_kp = robot.pid.kp
            pid_ki = robot.pid.ki
            pid_kd = robot.pid.kd
            
            if element.type == "curve":
                base_speed = int(base_speed * 0.7)
                max_speed = int(max_speed * 0.7)
                pid_kp *= 1.2  # More aggressive on curves
            elif element.type == "fork":
                base_speed = int(base_speed * 0.6)
                max_speed = int(max_speed * 0.6)
                pid_kp *= 1.5
            elif element.type == "obstacle":
                base_speed = int(base_speed * 0.5)
                max_speed = int(max_speed * 0.5)
            
            segments.append(SpeedSegment(
                segment_id=element_id,
                base_speed=base_speed,
                max_speed=max_speed,
                pid_kp=pid_kp,
                pid_ki=pid_ki,
                pid_kd=pid_kd,
                description=f"Segment {i}: {element.type}"
            ))
        
        return segments
    
    @staticmethod
    def generate_firmware(track: Track, robot: RobotConfig) -> FirmwareConfig:
        """Generate complete firmware code"""
        speed_strategy = FirmwareService.generate_speed_strategy(track, robot)
        
        # Generate firmware template
        code = FirmwareService._generate_code_template(robot, speed_strategy)
        
        return FirmwareConfig(
            robot_name=robot.name,
            platform=robot.platform,
            speed_strategy=speed_strategy,
            code=code
        )
    
    @staticmethod
    def _generate_code_template(robot: RobotConfig, segments: List[SpeedSegment]) -> str:
        """Generate C++ firmware code template"""
        
        # Build sensor pins array
        sensor_pins = ", ".join([f"A{i}" for i in range(robot.sensors.count)])
        
        code = f"""// LineFollowerOS Generated Firmware
// Robot: {robot.name}
// Platform: {robot.platform.upper()}
// Generated by LineFollowerOS v1.0.0

// ===== Configuration =====
#define NUM_SENSORS {robot.sensors.count}
#define MOTOR_LEFT_PIN1 {robot.motor_left.pins[0]}
#define MOTOR_LEFT_PIN2 {robot.motor_left.pins[1] if len(robot.motor_left.pins) > 1 else robot.motor_left.pins[0] + 1}
#define MOTOR_RIGHT_PIN1 {robot.motor_right.pins[0]}
#define MOTOR_RIGHT_PIN2 {robot.motor_right.pins[1] if len(robot.motor_right.pins) > 1 else robot.motor_right.pins[0] + 1}

// PID Configuration
float Kp = {robot.pid.kp};
float Ki = {robot.pid.ki};
float Kd = {robot.pid.kd};

// Speed Configuration
int baseSpeed = {robot.base_speed};
int maxSpeed = {robot.max_speed};

// ===== Global Variables =====
int sensorPins[NUM_SENSORS] = {{{sensor_pins}}};
int sensorValues[NUM_SENSORS];
int lastError = 0;
int integral = 0;

// ===== Setup =====
void setup() {{
  Serial.begin(9600);
  
  // Initialize motor pins
  pinMode(MOTOR_LEFT_PIN1, OUTPUT);
  pinMode(MOTOR_LEFT_PIN2, OUTPUT);
  pinMode(MOTOR_RIGHT_PIN1, OUTPUT);
  pinMode(MOTOR_RIGHT_PIN2, OUTPUT);
  
  // Initialize sensor pins
  for (int i = 0; i < NUM_SENSORS; i++) {{
    pinMode(sensorPins[i], INPUT);
  }}
  
  Serial.println("LineFollowerOS Ready!");
  delay(2000);
}}

// ===== Main Loop =====
void loop() {{
  readSensors();
  int position = calculatePosition();
  int correction = calculatePID(position);
  
  int leftSpeed = constrain(baseSpeed + correction, 0, maxSpeed);
  int rightSpeed = constrain(baseSpeed - correction, 0, maxSpeed);
  
  setMotorSpeeds(leftSpeed, rightSpeed);
}}

// ===== Sensor Functions =====
void readSensors() {{
  for (int i = 0; i < NUM_SENSORS; i++) {{
    sensorValues[i] = digitalRead(sensorPins[i]);
  }}
}}

int calculatePosition() {{
  int sum = 0;
  int count = 0;
  
  for (int i = 0; i < NUM_SENSORS; i++) {{
    if (sensorValues[i] == HIGH) {{
      sum += i * 1000;
      count++;
    }}
  }}
  
  if (count == 0) return -1;
  return sum / count - ((NUM_SENSORS - 1) * 500);
}}

// ===== PID Controller =====
int calculatePID(int position) {{
  if (position == -1) return 0;
  
  int error = position;
  integral += error;
  int derivative = error - lastError;
  lastError = error;
  
  // Prevent integral windup
  integral = constrain(integral, -1000, 1000);
  
  int correction = (Kp * error) + (Ki * integral) + (Kd * derivative);
  return correction;
}}

// ===== Motor Control =====
void setMotorSpeeds(int leftSpeed, int rightSpeed) {{
  // Left motor
  if (leftSpeed >= 0) {{
    analogWrite(MOTOR_LEFT_PIN1, leftSpeed);
    analogWrite(MOTOR_LEFT_PIN2, 0);
  }} else {{
    analogWrite(MOTOR_LEFT_PIN1, 0);
    analogWrite(MOTOR_LEFT_PIN2, -leftSpeed);
  }}
  
  // Right motor
  if (rightSpeed >= 0) {{
    analogWrite(MOTOR_RIGHT_PIN1, rightSpeed);
    analogWrite(MOTOR_RIGHT_PIN2, 0);
  }} else {{
    analogWrite(MOTOR_RIGHT_PIN1, 0);
    analogWrite(MOTOR_RIGHT_PIN2, -rightSpeed);
  }}
}}

// ===== Speed Strategy (Generated from track analysis) =====
// Total segments: {len(segments)}
"""
        
        for i, segment in enumerate(segments):
            code += f"// Segment {i}: {segment.description}\n"
            code += f"//   Speed: {segment.base_speed}-{segment.max_speed}, PID: Kp={segment.pid_kp}, Ki={segment.pid_ki}, Kd={segment.pid_kd}\n"
        
        return code
